0200	6a02		LD	Va 02 		; 패들1의 초기 x위치: x1 = 2
0202	6b0c		LD	Vb 0c 		; 패들1의 초기 y위치: y1 = 12
0204	6c3f		LD	Vc 3f 		; 패들2의 초기 x위치: x2 = 63
0206	6d0c		LD	Vd 0c 		; 패들2의 초기 y위치: y2 = 12
0208	a2ea		LD	I 2ea 		; 스프라이트 저장된 주소 지정
									; (I=0x2ea, [I]=0x80) 
020a	dab6		DRW	Va Vb 6		; 패들 1 그리기
020c	dcd6		DRW	Vc Vd 6 	; 패들 2 그리기
020e	6e00		LD	Ve 00		; Ve = 0x00 (상위비트는 왼쪽 패들 점수, 
									; 하위비트는 오른쪽 패들 점수)
0210	22d4		CALL	2d4 	; 주소 2d4로 분기하여 서브루틴 실행 
0212	6603		LD	V6 03		; 서브루틴 복귀후, 공의 초기x위치: 3
0214	6802		LD	V8 02		; 위아래로 패들이 움직이는 양:2픽셀
0216	6060		LD	V0 60		; 게임이 다시 재개되기 전 딜레이를 준다
									; 딜레이타이머 초기값 설정을 위한 값 
0218	f015		LD	DT v0 		; 딜레이타이머에 0x60을 넣는다
021a	f007		LD	V0 DT		; 딜레이타이머값이 
									; mainloop에서 정해진 시간마다 
									; 1씩 감소되어 갱신하면 v0를 업데이트
021c	3000		SE	V0 00		; V0가 0이라면 다음 명령어를 건너뜀
021e	121a		JP	21a			; 21a번지로 분기
0220	c717		RND	V7 17		; V0가 0이되었을때, 
									; V7에 랜덤한(0-255)숫자를 생성하여 
									; 17과 AND연산함 
0222	7708		ADD	V7 08		; V7에 8을 더하고 공의 초기y위치로 사용
0224	69ff		LD	V9 ff		; V9에 음수 (-1을 저장)
0226	a2f0		LD	I 2f0 		; 스프라이트 저장된 주소 지정
									; (I=0x2f0, [I]=0x80)
0228	d671		DRW	V6 V7 1		; 공을 지정된 위치에 그린다 
022a	a2ea		LD	I 2ea		; 스프라이트 저장된 주소 지정
									; (I=0x2ea, [I]=0x80) 
022c	dab6		DRW	Va Vb 6		; 패들1을 지정된 위치에 그린다 
022e	dcd6		DRW	Vc Vd 6		; 패들2을 지정된 위치에 그린다 
0230	6001		LD	V0 01 		; 플레이어1위쪽 y방향키에 해당하는 값 
0232	e0a1		SKNP	V0 		; 키보드로 플레이어1위쪽 방향키 눌렀다면, 
									; 다음 명령어로, 
									; 아니라면 스킵 
0234	7bfe		ADD	Vb fe 		; 플레이어1 패들을 y축 2픽셀 올림,
									; (fe:2의 보수 -2에 해당)
0236	6004		LD	V0 04  		; 플레이어1아랫쪽 y방향키에 해당하는 값 
0238	e0a1		SKNP	V0 		; 키보드로 패들 1아랫쪽 방향키 눌렀다면, 
									; 다음 명령어로, 
									; 아니라면 스킵 
023a	7b02		ADD	Vb 02  		; 플레이어1 패들을 y축 2픽셀 내림, 
023c	601f		LD	V0 1f 		; V0:바닥면끝 위치:31픽셀 
023e	8b02		AND	Vb V0 		; Vb:현재y위치
0240	dab6		DRW	Va Vb 6 	; 패들1을 지정된 위치에 그린다 
                                	; 6바이트만큼 I+0에 지정된 1바이트
                                	; (8픽셀을 가로로 그리고, I+5에 지정된 1바이트씩 총 5줄을 그린다 
0242	600c		LD	V0 0c 		; 플레이어2위쪽 c방향키에 해당하는 값
0244	e0a1		SKNP	V0 		; 키보드로 패들2 위쪽 방향키 눌렀다면, 
									; 다음 명령어로, 
									; 아니라면 스킵 
0246	7dfe		ADD	Vd fe 		; 패들2를 y축 2픽셀 올림, 
									; (fe:2의 보수 -2에 해당)
0248	600d		LD	V0 0d 		; 패들2의 아래쪽 d방향키에 해당하는 값 
024a	e0a1		SKNP	V0 		; 키보드로 패들2 아래쪽 방향키 눌렀다면, 
									; 다음 명령어로, 
									; 아니라면 스킵
024c	7d02		ADD	Vd 02 		; 플레이어1 패들을 y축 2픽셀 내림, 
024e	601f		LD	V0 1f 		; V0:화면 최하단 위치:y=31 
0250	8d02		AND	Vd V0  		; Vd: 화면의 맨위/맨아래에 패들 일부가 
									; 올라/내려가면 
									; wrapping하여 이어서 나타냄
0252	dcd6		DRW	Vc Vd 6 	; 패들1을 지정된 위치에 그린다 
									; 6바이트만큼 I+0에 지정된 1바이트
									; (8픽셀을 가로로 그리고, 
									; I+5에 지정된 1바이트씩 
									; 총 5줄을 그린다) 
0254	a2f0		LD	I 2f0  		; I에 주소 2f0저장, [I]=0x80
0256	d671		DRW	V6 V7 1 	; 공을 지정된 위치에 그린다 
                                	; 6바이트만큼 I+0에 지정된 1바이트
                                	; (8픽셀을 가로로 그리고, 
                                	; I+5에 지정된 1바이트씩 총 5줄을 그린다)
0258	8684		ADD	V6 V8 		; 공 x위치를 V8값에 의해 2픽셀 
									; 오른쪽(2)/왼쪽(-2)만큼 이동시킨다
025a	8794		ADD	V7 V9 		; 공 y위치를 V9값에 의해 1픽셀 
									; 위쪽(-1)/아래쪽(+1)만큼 이동시킨다
025c	603f		LD	V0 3f 		; V0: 화면 맨 오른쪽 위치:x=63
025e	8602		AND	V6 V0 		; Vd: 공이 x오른쪽 끝에 얼마나 도달했는지 체크
0260	611f		LD	V1 1f 		; V0: 화면 맨 아래족 위치:y=31
0262	8712		AND	V7 V1 		; V7: 공이 바닥면y에 얼마나 도달했는지 체크
0264	4602		SNE	V6 02 		; 공의 x위치가 2(가장 왼쪽, 
									; 또는 패들 1의 x위치)가 아니라면  
									; 다음 명령어를 건너뜀
0266	1278		JP	278			; 공의 x위치가 가장 왼쪽이라면 0x278로 분기
0268	463f		SNE	V6 3f		; 공의 위치가 화면 가장 오른쪽(패들 2)이
									; 아니라면 다음 명령어 스킵, 
									; 공의 위치가 화면 가장 오른쪽이라면 
									; 다음 명령어로 
026a	1282		JP	282			; 282번지로 분기
026c	471f		SNE	V7 1f		; 공의 위치가 화면 가장 아래쪽이 
									; 아니라면 다음 명령어 스킵, 
									; 공의 위치가 화면 가장 아래쪽이라면 
									; 다음 명령어로
026e	69ff		LD	V9 ff		; 공 y의 움직임 방향을 위쪽(-1)으로 세팅
0270	4700		SNE	V7 00		; 공의 위치가 화면 가장 위쪽이 아니라면 
									; 다음 명령어 스킵, 
									; 공의 위치가 화면 가장 위쪽이라면 
									; 다음 명령어로
0272	6901		LD	V9 01		; 공 y의 움직임 방향을 아래쪽(+1)으로 세팅
0274	d671		DRW	V6 V7 1		; 공의 현재 위치를 그려줌
0276	122a		JP	2a2			; 2a2번지로 분기
0278	6802		LD	V8 02		; 공의 이동 방향 V8을 오른쪽 +2로 바꿈 
027a	6301		LD	V3 01		; 오른쪽 패들이 이긴 경우 
									; 추가점수 V3를 1로 설정
027c	8070		LD	V0 V7 		; V0를 현재 공의 x위치(V7의 값)로 설정
027e	80b5		SUB	V0 Vb		; 공의 y위치에서 패들1의 y위치를 뺌	
0280	128a		JP	28a			; 28a 번지로 분기
0282	68fe		LD	V8 fe 		; 공의 이동 방향 V8을 왼쪽 -2로 바꿈 
0284	630a		LD	V3 0a 		; 왼쪽 패들이 이긴 경우 
									; 추가점수 V3를 0xa, 즉 10으로 설정
0286	8070		LD	V0 V7 		; V0를 현재 공의 x위치(V7의 값)로 설정
0288	80d5		SUB	V0 Vd		; 공의 y위치에서 패들2의 y위치를 뺌  
028a	3f01		SE	Vf 01		; 전의 뺄셈의 부호가 양수(true)라면, 
									; 즉 공의 위치가 더 아래라면 
									; 다음 명령어 건너뜀
									; 공의 y위치가 패들의 y위치와 같거나 
									; 위쪽이라면 다음 명령어로
028c	12a2		JP	2a2 		; 공의 y위치가 패들의 y위치보다 
									; 위쪽이라면 2a2 번지로 분기
028e	6102		LD	V1 02		; V1 = 2를 넣고 패들을 2칸씩 확인
0290	8015		SUB	V0 V1 		; 공의 y위치가 패들보다 아래인 경우
									; 공의 y위치와 패들의 y위치값 차이가 
									; 양수일때 v1만큼, 즉 2를 더 빼주며 
									; 패들 상단, 즉 패들의 0+2=2번째 블록과 
									; 걸리는지 확인 
									; 연산의 결과가 음수 혹은 0이라면, 
									; VF=0; 걸린 것
									; 결과가 양수라면 
									; VF=1; 아직 떨어져있음.   
0292	3f01		SE	Vf 01 		; 패들 현재 블록y 위치내에 
									; 공이 걸리지 않았다면 
									; 다음 명령어 건너뜀,
									; 패들의 현재 블록y 위치와 
									; 공의 y위치가 겹친다면 
									; 다음 명령어로 
0294	12ba		JP	2ba			; (패들 상단반사 처리)2ba 주소로 분기
0296	8015		SUB	V0 V1 		; 공의 y위치가 패들보다 아래인 경우
									; 공의 y위치와 패들의 y위치값 차이가 
									; 양수일때 v1만큼, 즉 2를 더 빼주며 
									; 패들 중단, 즉 
									; 패들의 2+2=4번째 블록과 걸리는지 확인 
									; 연산의 결과가 음수 혹은 0이라면, 
									; VF=0; 걸린 것
									; 결과가 양수라면 VF=1; 아직 떨어져있음.   
0298	3f01		SE	Vf 01 		; 패들 현재 블록y 위치내에 
									; 공이 걸리지 않았다면 
									; 다음 명령어 건너뜀,
									; 패들의 현재 블록y 위치와 
									; 공의 y위치가 겹친다면 
									; 다음 명령어로 
029a	12c8		JP	2c8			; (패들 중단반사 처리) 2c8 주소로 분기
029c	8015		SUB	V0 V1 		; 거기서 v1만큼, 즉 2를 더 빼주며 
									; 패들 하단, 
									; 즉, 패들의 4+2=6번째 블록과 걸리는지 확인 
									; 연산의 결과가 음수 혹은 0이라면, 
									; VF=0; 걸린 것
									; 결과가 양수라면 
									; VF=1; 아직 떨어져있음.  
029e	3f01		SE	Vf 01 		; 패들 현재 블록y 위치내에 
									; 공이 걸리지 않았다면 
									; 다음 명령어 건너뜀,
									; 패들의 현재 블록y 위치와 
									; 공의 y위치가 겹친다면 
									; 다음 명령어로
02a0	12c2		JP	2c2 		; (패들 하단반사 처리)2c2 주소로 분기
02a2	6020		LD	V0 20 		; V0 = 20 (약간 긴 비프음 사운드)
02a4	f018		LD	ST V0 		; 승패 가려짐, 
									;사운드 타이머를 0x20으로 설정
02a6	22d4		CALL	2d4 	; 서브루틴 2d4로 분기 승부가 나서
									; 점수그려주는 부분으로 이동
02a8	8e34		ADD	Ve V3 		; Ve점수에 왼쪽 패들이 이기면 
									; V3=0x01을 더하고
									; 오른쪽 패들이 이기면 
									; V3=0x0a=10을 더해서 점수 구분 
02aa	22d4		CALL	2d4	 	; 서브루틴 2d4로 분기; 
									; 승부가 나서 점수그려주는 부분으로 이동
02ac	663e		LD	V6 3e 		; V6 = 0x32 = 62
02ae	3301		SE	V3 01		; V3==1이라면, 즉, 패들2가 이겼다면 
									; 다음 명령어 건너뛰기, 
									; V3!=1이라면, 즉 패들1이 이겼다면 
									; 다음 명령어 실행 
02b0	6603		LD	V6 03 		; 패들1이 이겼다면, 
									; 공의 x위치를 패들1의 초기 위치 3으로 지정
02b2	68fe		LD	V8 fe 		; 패들2가 이겼다면, 
									; 공의 x진행방향을 왼쪽 방향(-2)으로 설정
02b4	3301		SE	V3 01		; 패들2가 이겼다면 다음 명령어 건너뛰기
									; 패들1이 이겼다면 다음 명령어 실행
02b6	6802		LD	V8 02 		; 패들1가 이겼다면, 공의 x진행방향을 
									; 오른쪽 방향(+2)으로 설정
02b8	1216		JP	216 		; 216번지로 분기
02ba	79ff		ADD	V9 ff 		; 패들 상단에 공이 접촉했을때
									; 반사되는 공의 y진행방향을 
									; 원래 진행방향에서 -1을 더하여 
									; 약간 위쪽 방향으로 반사되도록 설정
02bc	49fe		SNE	V9 fe 		; 공의 y진행방향이 -1 + -1= -2로, 
									; -1값을 초과했다면 다음 명령어 건너뒤기
									; 공의 y진행방향이 위쪽방향 -2라면 
									; 다음 명령어로 
02be	69ff		LD	V9 ff		; 공의 y진행방향을 -1로 고정
02c0	12c8		JP	2c8 		; 패들 하단에 공이 접촉했을때
02c2	7901		ADD	V9 01 		; 반사되는 공의 y진행방향을
									; 원래 진행방향에서 +1을 더하여 
									; 약간 아래 방향으로 반사되도록 설정
02c4	4902		SNE	V9 02 		; 공의 y진행방향이 +1 + +1= +2로, 
									; +2값을 초과했다면
02c6	6901		LD	V9 01 		; 공의 y진행방향을 +1로 고정
02c8	6004		LD	V0 04 		; 패들에 상/중/하단이든 
									; 어쨌든 공이 접촉했을때
02ca	f018		LD	ST V0 		; 사운드 타이머값에 짧은 비프음을 내게 함
02cc	7601		ADD	V6 01 		; 현재 공의 x위치를 +1만큼 더했을 때
02ce	4640		SNE	V6 40 		; 그 위치가 화면의 오른쪽 바깥
									; 즉 x==64가 아니라면 
									; 패들2에 닿은 것이 아니라, 
									; 패들1에 닿은 것이라면
									; 다음 명령어 건너뛰기
02d0	76fe		ADD	V6 fe  		; 패들 1에 닿은 것이라면
									; 공을 움직이기 전에 
									; x위치를 왼쪽으로 한 픽셀 이동시켜줌
02d2	126c		JP	26c 		; 26c 번지로 분기하여 반사된 상태에서 
									; 계속 플레이하게 함
02d4	a2f2		LD	I 2f2		; 스프라이트가 저장된 주소 지정
									; (I=0x2f2, [I]=0x00) 
02d6	fe33		LD	B Ve		; Ve에 저장된 값(초기: 0)을 
									; BCD 형태로 메모리 주소 I+0, I+1, I+2에 
									; 저장(초기:0x2f2, 0x2f3, 0x2f4) 
02d8	f265		ADD	V2 [I]		; 메모리에서 I주소안에 들어있는 값[I]을 
									; 찾아 V2에 더해줌
02da	f129		LD	F V1		; 패들1의 점수: 
									; V1번째 캐릭터 스프라이트가 들어있는 
									; 주소를 I에 환산하여 입력: 
									; (ex; '7'-> V1=7, 
									; I= V1*5바이트=35;0x23)  
02dc	6414		LD	V4 14		; 패들1의 점수 x위치: V4=0x14 
02de	6500		LD	V5 00		; 패들1의 점수 y위치: V5=0x00
02e0	d455		DRW	V4 V5 5		; 패들1의 점수 그리기
02e2	7415		ADD	V4 15		; 패들2의 점수 x위치: V4=0x14+0x15=0x29=41
02e4	f229		LD	F V2 		; 패들2의 점수:V2번째 캐릭터 스프라이트가 
									; 들어있는 주소를 I에 환산하여 입력: 
									; (ex; '7'-> V1=7, I= V1*5바이트=35;0x23)
02e6	d455		DRW	V4 V5 5		; 패들2의 점수 그리기
02e8	00ee		RET				; 복귀
02ea	8080		0x80 0x80  		; 데이터 
02ec	8080		0x80 0x80  		; 데이터
02ee	8080		0x80 0x80		; 데이터
02f0	8000		0x80 0x80		; 데이터
02f2	0000	    0x00 0x00		; 데이터
02f4	0000		0x00 0x00		; 데이터
